**Объект тестирования (Test Object / Application Under Test - AUT)** — это любой артефакт или компонент программного обеспечения, который подвергается проверке для оценки его качества. В зависимости от стадии жизненного цикла и целей тестирования, объекты могут быть разными, и к ним применяются специфические подходы.

объектом исследования можно назвать **Application Under Test (AUT)**
### **I. Классификация объектов тестирования и подходы к их тестированию**

Объекты можно классифицировать по уровню детализации и готовности.
1. **Тестирование требований и спецификаций**
	**Объект:** Документы с требованиями (ТЗ, пользовательские истории, use case), архитектурные спецификации.
	**Цель тестирования:** Выявить неоднозначности, противоречия, пробелы, нефункциональные лакуны до начала реализации. **Профилактика самых дорогих ошибок.**
	**Подходы:**
	- **Статический анализ (Review):** Неформальные обсуждения, формальные инспекции.
	- **Анализ трассируемости:** Проверка полноты покрытия требований от бизнес-целей до тест-кейсов.
	- **Прототипирование:** Быстрое создание макетов (например, UI-прототипов) для валидации требований с пользователем.
2. **Тестирование дизайна и архитектуры**
	**Объект:** Архитектурные диаграммы (С4, UML), схемы БД (ERD), описания API.
	**Цель:** Проверить соответствие требованиям, выявить архитектурные риски (производительность, масштабируемость), оценить связность/зацепление.
	**Подходы:**
	- **Архитектурные обзоры:** Коллективная оценка решений
	- **Моделирование и оценка:** Использование методов (например, [[CAP-теорема]] для распределенных систем) для анализа последствий выбора.
	- **Статический анализ моделей:** Проверка корректности UML-диаграмм.
3. **Тестирование кода (модульное и интеграционное)**
	**Объект:** Исходный код — отдельные функции, методы, классы (модули) и их взаимодействие.
	**Цель:** Убедиться в корректности работы минимальных единиц программы и их совместной работы.
	**Подходы:**
	- **Модульное тестирование (Unit Testing):**
		**Объект:** Изолированный модуль (класс, функция).
		**Подход:** **Метод «белого ящика»**. Использование **фреймворков (JUnit, pytest)**. Создание тестов, проверяющих все возможные пути выполнения (покрытие). Использование **заглушек (stubs)** и **моков (mocks)** для изоляции.
	- **Интеграционное тестирование (Integration Testing):**
		**Объект:** Группа взаимодействующих модулей, подсистема.
		**Подход:** **Метод «серого ящика»**. Проверка корректности взаимодействия через API, передачи данных, работы с БД. Используются **интеграционные тестовые среды**, приближенные к реальным.
4. **Тестирование собранной системы (системное тестирование)**
	**Объект:** Полностью собранное, интегрированное приложение (AUT) в среде, приближенной к продуктивной.
	**Цель:** Проверить соответствие системы всем заявленным функциональным и нефункциональным требованиям как единому целому.
	**Подходы (широкий спектр, зависит от цели):**
	- **Функциональное тестирование (Functional Testing):**
		 Проверка функций системы. **Подход: «черный ящик»**. Техники: эквивалентное разбиение, анализ граничных значений, тестирование на основе сценариев использования.
	- **Нефункциональное тестирование:**
		- **Нагрузочное/Стресс-тестирование (Performance/Load/Stress):** Проверка поведения под нагрузкой. **Подход:** Использование специализированных инструментов (JMeter, k6) для имитации пользовательской нагрузки.
		- **Тестирование удобства использования (Usability Testing):** Оценка UI/UX. **Подход:** Привлечение реальных пользователей, экспертные оценки, сбор метрик.
		- **Тестирование безопасности (Security Testing):** Поиск уязвимостей. **Подход:** Статический анализ кода (SAST), динамический анализ (DAST), пентест.
		- **Тестирование совместимости (Compatibility Testing):** Проверка работы в разных браузерах, ОС, устройствах.
5. **Тестирование процесса развертывания и конфигурации**
	**Объект:** Процесс сборки, установки, настройки и обновления системы.
	**Цель:** Убедиться, что систему можно корректно развернуть в целевой среде.
	**Подходы:**
	- **Смоук-тестирование (Smoke/Sanity):** Быстрая проверка работоспособности ключевых функций после сборки или деплоя. **«Минимальными усилиями обнаружить максимум ошибок»**
	- **Регрессионное тестирование (Regression Testing):** Проверка, что новое обновление или исправление не сломало существующую функциональность. **Подход:** Активное использование **автоматизированных тестов**
	- **Тестирование отката (Rollback Testing):** Проверка процедуры возврата к предыдущей стабильной версии.
6. **Приемочное тестирование (User Acceptance Testing - UAT)**
	**Объект:** Готовая система в максимально приближенной к реальности среде.
	**Цель:** **Валидация** — подтверждение, что система удовлетворяет реальные потребности заказчика и готова к эксплуатации. **«Полноценный эксперимент по достижению целей»**
	**Подход:** Выполняется **заказчиком или конечными пользователями**. Используются реальные бизнес-сценарии и данные. Фокус на **удобство и полезность**, а не на техническую корректность.

### **II. Связь объектов тестирования с фазами жизненного цикла и стадиями версии**

В итеративной разработке подход к тестированию объектов меняется в зависимости от стабильности версии:
1. **Ранняя (нестабильная) версия:** Объект — **сырой билд**. Подход — **«дымовое» (smoke) тестирование** критически важных функций.
2. **Относительно стабильная версия:** Объект — **прошедший smoke-тест билд**. Подход — **санитарное (sanity) тестирование** заявленной функциональности и **углубленное функциональное тестирование**.
3. **Финальная версия (после исправлений):** Объект — **кандидат на релиз**. Подход — **регрессионное тестирование** и **приемочное тестирование**.
### **Вывод**

Объекты тестирования охватывают **весь спектр артефактов разработки** — от текстовых требований до работающей системы. Подход к тестированию каждого объекта строго зависит от:
- **Его природы** (текст, код, собранное приложение).
- **Цели проверки** (верификация корректности vs. валидация полезности).
- **Стадии ЖЦ** (ранний анализ vs. финальный релиз).

Эффективный процесс обеспечения качества строится на **комбинации подходов**: статического анализа артефактов на ранних этапах, автоматизированного модульного и интеграционного тестирования кода, системного тестирования методом «черного ящика» и, наконец, валидации через приемочное тестирование. Понимание специфики каждого объекта тестирования позволяет правильно планировать усилия, выбирать инструменты и минимизировать риски на всех этапах создания ПО.