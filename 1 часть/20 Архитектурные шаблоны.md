**Архитектурный шаблон (Architectural Pattern)** — это высокоуровневое, проверенное временем решение типовой проблемы проектирования программной системы. Он задает **фундаментальную структурную организацию** приложения, определяя набор компонентов, их роли, ответственность и способы взаимодействия. В отличие от шаблонов проектирования (Design Patterns), которые решают локальные задачи организации кода, архитектурные шаблоны определяют **скелет всей системы**

### **I. Ключевые характеристики и цели**

- **Повторяемость:** Решает проблему, которая возникает вновь и вновь в разных проектах.
- **Абстракция высокого уровня:** Описывает систему на уровне крупных блоков (модулей, сервисов, слоев).
- **Задает ограничения:** Определяет, что можно и чего нельзя делать в рамках этой архитектуры, задавая вектор для дальнейшего проектирования.
- **Связывает архитектурные характеристики (качества):** Каждый шаблон лучше всего подходит для обеспечения определенного набора нефункциональных требований (масштабируемость, сопровождаемость, надежность).
### **II. Основные архитектурные шаблоны (на основе классификации М. Ричардса**)

1. **Слоистая архитектура (Layered / N-Tier Architecture)** ([[Слоистая архитектура]])
	Система организована в **горизонтальные слои**, каждый из которых имеет четкую ответственность. Запрос проходит через слои последовательно, сверху вниз.
	**Типичные слои:** Презентационный (UI), Бизнес-логики (Service/Domain), Доступа к данным (Persistence/Data Access)
	**Преимущества:** Высокая **связность (cohesion)** внутри слоя, простота понимания, возможность замены одного слоя без изменения других.
	**Недостатки:** Риск создания «жирного» слоя бизнес-логики, потенциальные проблемы с производительностью при прохождении через все слои, сложность масштабирования отдельных слоев.
	**Применение:** Традиционные бизнес-приложения, корпоративные системы. **Один из самых распространенных шаблонов.**
2. **Архитектура «Микросервисы» (Microservices Architecture)** ([[Микросервисная архитектура]])
	Приложение разбивается на множество **небольших, слабо связанных, автономно развертываемых сервисов**. Каждый сервис отвечает за одну бизнес-возможность (business capability), имеет свою базу данных и общается с другими через легковесные механизмы (чаще всего HTTP/REST, сообщения).
	**Преимущества:** **Независимое масштабирование** сервисов, **независимое развертывание**, разные сервисы можно писать на разных стеках, отказоустойчивость.
	**Недостатки:** Высокая сложность распределенной системы (сетевые задержки, отказы, консистентность данных — **CAP-теорема**), сложность мониторинга и отладки, накладные расходы на межсервисное взаимодействие.
	**Применение:** Крупные, сложные, эволюционирующие системы с высокими требованиями к масштабируемости и скорости доставки (облачные приложения, стриминговые платформы).
3. **Событийно-ориентированная архитектура ([[Event-Driven Architecture]] - EDA)**
	Компоненты системы взаимодействуют путем **асинхронной генерации и потребления событий**. Центральную роль играет **брокер сообщений (Message Broker)**, который доставляет события от издателей (producers) подписчикам (consumers).
	**Основные стили:** **Публикация-подписка (Pub/Sub)** и **Очереди сообщений (Message Queues)**.
	**Преимущества:** **Слабая связанность (loose coupling)** компонентов, **высокая масштабируемость** и отзывчивость (реактивность), лучшее восприятие пиковых нагрузок.
	**Недостатки:** Сложность обеспечения **конечной согласованности (Eventual Consistency)**, трудности в отслеживании потока событий и отладке, зависимость от надежности брокера.
	 **Применение:** Системы реального времени, биржевые торговые системы, стриминговые платформы, системы, где компоненты должны реагировать на изменения состояния.
4. **Клиент-серверная архитектура** 
	Основана на четком разделении функциональности между клиентом (запрашивающей стороной) и сервером (предоставляющей ресурсы и услуги).
	Эта архитектура стала основой интернета и продолжает доминировать в разработке веб-приложений, мобильных сервисов и корпоративных систем 
5. **Архитектура «Микроядро» (Plug-in / Microkernel Architecture)**
	Состоит из **минимального ядра (core system)**, которое содержит только базовую, необходимую для работы функциональность, и множества **подключаемых модулей (plug-in modules)**, которые добавляют дополнительные возможности.
	**Преимущества:** Высокая **расширяемость** и **гибкость**, возможность «горячего» добавления функциональности, хорошая изоляция модулей.
	 **Недостатки:** Сложность проектирования контрактов (интерфейсов) между ядром и модулями, потенциальные проблемы с производительностью из-за накладных расходов на взаимодействие.
	 **Применение:** Интегрированные среды разработки (IDE, например, Eclipse), браузеры, банковские приложения, где требуется поддержка множества вариантов и конфигураций.
6. **Пространственная архитектура (Space-Based Architecture)**
	Предназначена для решения проблем **экстремальной масштабируемости** и **одновременного доступа большого числа пользователей**. Основана на распределенной сетке (tuple space), в которой данные и бизнес-логика реплицируются между множеством серверов, обрабатывающих запросы.
	**Преимущества:** Практически линейная масштабируемость, высочайшая отказоустойчивость и доступность.
	**Недостатки:** Чрезвычайная сложность реализации и сопровождения, неприменимость для систем с требованием строгой консистентности данных (ACID)
	**Применение:** Высоконагруженные веб-сайты с непредсказуемыми пиками нагрузки (онлайн-распродажи, билетные системы), системы массовых онлайн-игр.
7. **Шестиугольная (Hexagonal) / Порты и адаптеры** ([[Шестиугольная архитектура]])
	Шестиугольная архитектура делит программное обеспечение на несколько слабосвязанных компонентов: ядро проекта, база данных, пользовательский интерфейс и другие. Каждый компонент соединён с другим через ряд открытых «портов».
8. **Чистая Архитектура ([[Clean Architecture]])**
	Это эволюция и ужесточение правил Layered Architecture. 
	Архитектурный шаблон, предложенный Робертом Мартином (известным также как «Дядя Боб»). Главная идея — **разделение приложения на независимые слои**, каждый из которых выполняет конкретную функцию. Эти слои взаимодействуют между собой через чётко определённые интерфейсы, что позволяет достичь высокой гибкости и расширяемости приложения.
	Цель Clean Architecture — создать модульный и гибкий код, который легко поддерживать и расширять. В центр ставится Entities и Domain и Бизнес-правила
### **III. Связь с другими концепциями курса**

1. **Архитектурный стиль vs. Шаблон**:
	Шаблон — это **конкретная реализация** более абстрактного **стиля**. Например, микросервисы — это шаблон, реализующий **распределенный стиль**.
2. **Связность (Cohesion) и связанность (Coupling)**
	Выбор шаблона напрямую влияет на эти метрики. Микросервисы стремятся к **минимальной связанности**, а слоистая архитектура — к **высокой связности внутри слоя**.
3. **Domain-Driven Design (DDD)**
	Такие шаблоны, как **Шестиугольная (Hexagonal) / Порты и адаптеры** и **Чистая Архитектура (Clean Architecture)**, являются архитектурными шаблонами, которые напрямую поддерживают принципы DDD, изолируя **доменный слой (ядро)** от деталей инфраструктуры
4. **DevOps и CI/CD**
	Шаблон **Микросервисы** идеально сочетается с практиками DevOps, позволяя независимо тестировать, собирать и развертывать каждый сервис. **Контейнеризация (Docker)** часто используется для упаковки микросервисов.
### **Вывод**

Архитектурные шаблоны — это **ключевой инструмент архитектора** для трансляции нефункциональных требований (масштабируемость, надежность, сопровождаемость) в конкретную структурную организацию системы. Не существует «лучшего» шаблона — есть **наиболее подходящий** для конкретного контекста, определяемого требованиями, ограничениями и компетенциями команды. Современные сложные системы часто используют **гибридный подход**, комбинируя несколько шаблонов (например, микросервисы, взаимодействующие через событийную шину, внутри себя могут быть построены по послойной или шестиугольной архитектуре). Понимание сильных и слабых сторон каждого шаблона позволяет принимать обоснованные архитектурные решения, которые закладывают основу для успешной разработки и долгосрочной эволюции программного продукта.